# N-Queens Problem Solver

This project provides a Java implementation to solve the classic N-Queens problem using backtracking. The goal is to place `n` queens on an `n x n` chessboard such that no two queens threaten each other (no two queens share the same row, column, or diagonal).

---

## Features

- Solves the N-Queens problem for any board size `n >= 1`.
- Returns all distinct solutions.
- Each solution is represented as a list of strings, where `'Q'` denotes a queen and `'.'` denotes an empty square.
- Uses a clear and standard backtracking approach.

---

## How It Works

1. **Initialization:**  
   - An empty `n x n` chessboard is created and filled with `'.'`.
2. **Backtracking:**  
   - The algorithm attempts to place a queen in each row, one by one.
   - For each column in the current row, it checks if placing a queen is safe (no other queen in the same column, left diagonal, or right diagonal).
   - If safe, it places the queen and recursively proceeds to the next row.
   - If all rows are filled, the current board configuration is added to the list of solutions.
   - The algorithm backtracks to try other possible placements.
3. **Safety Check:**  
   - The `isSafe` method checks for conflicts in the same column, left diagonal, and right diagonal above the current row.

---











# DependencyChecker: Circular Dependency Detection

This project provides a Java implementation to detect circular dependencies (cycles) in a directed graph, commonly used to check for issues in dependency graphs (such as software modules, tasks, or courses).

---

## Features

- Detects if a circular dependency exists in a directed graph.
- Accepts any number of nodes and directed edges.
- Efficient DFS-based algorithm with state tracking.

---

## How It Works

1. **Graph Construction:**  
   - The graph is built from the given number of nodes `n` and an edge list `edges`, where each edge is `[from, to]`.

2. **Cycle Detection:**  
   - The algorithm uses depth-first search (DFS) to traverse the graph.
   - Each node is marked as:
     - `0`: unvisited
     - `1`: visiting (currently in the recursion stack)
     - `2`: visited (fully explored)
   - If a node is encountered in the visiting state (`1`), a cycle is detected.

3. **Result:**  
   - Returns `true` if any cycle is found, otherwise `false`.

---


















# WeatherTrack

WeatherTrack is an Android app that allows users to track daily weather statistics in their city. The app fetches weather data from a mock API, stores it locally every 6 hours, and displays a weekly summary with temperature trends and details.

---

## Features

- *Fetch Weather:*  
  Retrieves temperature, humidity, and condition from a mock API. Each fetch is saved in a local Room database with a timestamp.

- *Auto Background Sync:*  
  Uses WorkManager to fetch and store weather data every 6 hours automatically. Users can also refresh data manually.

- *Weekly Summary Screen:*  
  Shows a graph and list of temperature changes over the past 7 days. Tap any day to view detailed weather info.

- *Architecture:*  
  Built with Java and MVVM, with clear separation between ViewModel, Repository, and Data Source (API and Database).

- *Error Handling:*  
  Displays user-friendly messages for:
  - No internet connection
  - API errors
  - Database errors

---


## Project Structure

com.example.weathertrack/
│
├── MainActivity.java
├── WeeklySummaryActivity.java
│
├── data/
│   ├── WeatherEntity.java
│   ├── WeatherDao.java
│   └── WeatherDatabase.java
│
├── network/
│   └── WeatherApiService.java
│
├── repository/
│   └── WeatherRepository.java
│
├── viewmodel/
│   └── WeatherViewModel.java
│
├── worker/
│   └── WeatherSyncWorker.java
│
├── utils/
│   ├── NetworkUtils.java
│   └── Result.java
│
res/
├── layout/
│   ├── activity_main.xml
│   └── activity_weekly_summary.xml
├── values/
│   └── strings.xml

---

## How It Works

1. *Fetching Weather:*  
   Weather data is generated by a mock API and stored in a Room database.

2. *Background Sync:*  
   WorkManager schedules a job to fetch and save weather data every 6 hours.

3. *Weekly Summary:*  
   The app displays a line graph (MPAndroidChart) and a list of the past 7 days’ temperatures. Tapping a data point or list item shows detailed stats for that day.

4. *Error Handling:*  
   The app checks for internet connectivity and handles API/database errors, displaying clear messages.

---
