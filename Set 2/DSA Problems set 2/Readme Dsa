# N-Queens Problem Solver

This project provides a Java implementation to solve the classic N-Queens problem using backtracking. The goal is to place `n` queens on an `n x n` chessboard such that no two queens threaten each other (no two queens share the same row, column, or diagonal).

---

## Features

- Solves the N-Queens problem for any board size `n >= 1`.
- Returns all distinct solutions.
- Each solution is represented as a list of strings, where `'Q'` denotes a queen and `'.'` denotes an empty square.
- Uses a clear and standard backtracking approach.

---

## How It Works

1. **Initialization:**  
   - An empty `n x n` chessboard is created and filled with `'.'`.
2. **Backtracking:**  
   - The algorithm attempts to place a queen in each row, one by one.
   - For each column in the current row, it checks if placing a queen is safe (no other queen in the same column, left diagonal, or right diagonal).
   - If safe, it places the queen and recursively proceeds to the next row.
   - If all rows are filled, the current board configuration is added to the list of solutions.
   - The algorithm backtracks to try other possible placements.
3. **Safety Check:**  
   - The `isSafe` method checks for conflicts in the same column, left diagonal, and right diagonal above the current row.

---






# DependencyChecker: Circular Dependency Detection

This project provides a Java implementation to detect circular dependencies (cycles) in a directed graph, commonly used to check for issues in dependency graphs (such as software modules, tasks, or courses).

---

## Features

- Detects if a circular dependency exists in a directed graph.
- Accepts any number of nodes and directed edges.
- Efficient DFS-based algorithm with state tracking.

---

## How It Works

1. **Graph Construction:**  
   - The graph is built from the given number of nodes `n` and an edge list `edges`, where each edge is `[from, to]`.

2. **Cycle Detection:**  
   - The algorithm uses depth-first search (DFS) to traverse the graph.
   - Each node is marked as:
     - `0`: unvisited
     - `1`: visiting (currently in the recursion stack)
     - `2`: visited (fully explored)
   - If a node is encountered in the visiting state (`1`), a cycle is detected.

3. **Result:**  
   - Returns `true` if any cycle is found, otherwise `false`.

---



